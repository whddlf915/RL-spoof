핵심 변경사항
1. 환경 메모리 추가 (SIE_SAC_paper.py:365-368)

# 1-step delayed spoofing offset (MDP state memory)
# Action a_t generates offset that is applied in next step
# This ensures s_{t+1} has consistent time indices: x^e_{t+1} and x^s_{t+1}
self.last_spoof_offset = np.zeros((n_envs, 3), dtype=np.float64)
2. Reset에서 초기화 (SIE_SAC_paper.py:451)

self.last_spoof_offset[indices] = 0.0  # No spoofing at initialization
3. step() 로직 재설계 (SIE_SAC_paper.py:466-545)
새로운 타임라인:


# 1. Action a_t → new_spoof_offset 계산 (다음 스텝용)
new_spoof_offset = self._spherical_to_cartesian(actions)

# 2. UAV에는 이전 스텝의 offset 적용
deceptive_pos = radar_est_t + self.last_spoof_offset

# 3. gamma_s는 현재 적용 중인 offset 기반
gamma_s, M_radar = self._calculate_predicted_nis(self.last_spoof_offset)

# 4. 환경 시뮬레이션 → radar_est_t1

# 5. 다음 상태 s_{t+1} - 시간 인덱스 일치!
deceptive_pos_t1 = radar_est_t1 + new_spoof_offset  # 둘 다 t+1
obs = self._get_observations(..., radar_est_t1, deceptive_pos_t1, ...)

# 6. Offset 업데이트 (다음 스텝용)
self.last_spoof_offset = new_spoof_offset.copy()
문제 해결 결과
✅ (1) 시간 인덱스 일관성 (논문 Eq. 29)
Before:

s_{t+1} = [x^e_{t+1}, x^s_{t}, ...] ❌ (시간 불일치)
After:

s_{t+1} = [x^e_{t+1}, x^s_{t+1}, ...] ✓ (같은 시간!)
x^s_{t+1} = x^e_{t+1} + new_spoof_offset
✅ (2) γ^s 계산 명확화
주석 수정:

"nav_kf update 후에 γ^s를 계산해야 S가 최신" ❌
"Paper Eq.17-18: γ^s uses radar_kf state covariance M (NOT nav_kf S!)" ✓
코드는 이미 올바름:


gamma_s, M_radar = self._calculate_predicted_nis(self.last_spoof_offset)
radar_kf의 M 사용 (맞음)
nav_kf의 S와 무관 (맞음)
논문 근거
Eq. 29: State s_k는 같은 시간 k의 모든 요소 포함
Proposition 1: k와 k-1의 offset이 함께 영향 → state에 offset 포함이 자연스러움
물리적 의미: GPS 스푸핑 신호는 연속적, action 효과가 다음 스텝에 나타남
예상 효과
이 수정으로 학습 안정성이 크게 향상될 것입니다:

Critic이 일관된 state transition 학습 가능
Value 추정의 분산 감소
Policy가 더 일관된 offset 생성
ρ→0 collapse 완화 가능성