3) “결과가 잘 안 나오는” 원인 후보: step()에서 특히 위험한 불일치/버그 포인트

여기부터가 핵심이야. 학습이 꼬이는 패턴이 나올 수 있는 부분들이 step에 꽤 보여.

(1) 다음 상태(obs)에서 시간 인덱스가 섞여 있음

step은 obs를 만들 때:

radar_est로는 **t+1의 radar_est_t1 (=x^e_{t+1})**를 넣고 

SIE_SAC_paper

그런데 deceptive_pos는 **t에서 만든 x^s_t (=x^e_t+Δx^s_t)**를 그대로 넣어. 

SIE_SAC_paper

문제는 _get_observations() 내부 주석이 “radar_est와 deceptive_pos가 같은 time step이어야 한다”는 전제를 이미 깔고 있어. (특히 fallback 재계산 설명에서 그 전제를 노골적으로 말함) 

SIE_SAC_paper

즉, s2(삼각형 각) 계산에 들어가는 spoof_pos가 t의 값인데 s1은 t+1 레이더 좌표라서, 상태가 논문 정의와 어긋나거나 최소한 “일관된 k시점 상태”가 아닐 가능성이 커. 이건 학습 난이도를 크게 올릴 수 있어.

증상: critic이 상태-전이 일관성을 못 잡고 value가 튀거나, policy가 이상한 offset을 내다가 수렴이 안 되는 패턴.

(2) γ^s 계산 주석과 실제 계산이 서로 안 맞음 (nav_kf와 무관하게 계산됨)

step에서 “nav_kf update 후에 γ^s를 계산해야 S가 최신”이라고 적어놨지만 

SIE_SAC_paper


실제 _calculate_predicted_nis()는 레이더 KF의 state covariance(M_radar)를 가져와 Σ^s를 만들고 

SIE_SAC_paper


거기에 **고정 sigma_spoof=10.0**을 더해서 γ^s를 계산해. 

SIE_SAC_paper

즉,

nav_kf의 innovation covariance(S)랑은 직접 연결이 없고

“언제 계산하느냐( nav_kf update 전/후 )”가 γ^s에 거의 영향을 안 줄 수 있어.

이 불일치는 **논문 의도(γ^s가 탐지 제약을 반영)**와 다르게 γ^s가 “그냥 오프셋 마할라노비스 거리”로만 굳어질 수 있어. (특히 sigma_spoof가 튜닝이 안 맞으면 γ^s 스케일이 망가짐)
모델 기반 해법보다 최대 엔트로피 강화학습(MERL) 이 적합하다.”